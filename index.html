<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>公車路徑規劃系統</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css" />
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f2f5; margin: 0; padding: 20px; }
        .main-container { display: flex; gap: 20px; width: 1000px; height: 620px; }
        /* 固定畫布尺寸，防止變形 */
        #mapCanvas { background: white; border: 2px solid #333; width: 600px; height: 600px; flex-shrink: 0; }
        .panel { flex: 1; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); overflow-y: auto; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button { padding: 10px; cursor: pointer; border: 1px solid #ccc; background: #eee; border-radius: 4px; font-weight: bold; }
        button.active { background: #3498db; color: white; }
        #btn-run { background: #27ae60; color: white; grid-column: span 2; margin-top: 10px; border: none; }
        .result-box { margin-top: 15px; background: #2c3e50; color: #fff; padding: 15px; border-radius: 5px; font-family: monospace; white-space: pre-wrap; font-size: 13px; }
    </style>
</head>
<body>
    <!-- <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <div id="technical-report" style="padding: 40px; background: #fff; border-bottom: 4px solid #34495e; font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif;">
        <h1 style="text-align: center; color: #2c3e50; font-size: 2em; margin-bottom: 10px;">題目二：公車路線與站點設置規劃</h1>

        <div style="max-width: 1100px; margin: 0 auto;">
            
        <section style="margin-bottom: 40px; background: #fffdf0; padding: 25px; border-radius: 12px; border: 2px solid #f1c40f;">
            <h2 style="color: #d35400; border-left: 6px solid #d35400; padding-left: 15px; margin-bottom: 20px;">(0). 建模核心思考：目標衝突與動態平衡</h2>
            
            <div style="font-size: 1.05em; line-height: 1.8; color: #444;">
                <p>在設計城市運輸系統時，我們面臨一個Trade-off</b>：</p>
                <ul style="margin: 15px 0;">
                    <li><b>營運方成本：</b> 站點越多、路徑越長，則燃油與維護成本越高（目標 A 最小化營運成本）。</li>
                    <li><b>使用者便利：</b> 若要最大程度縮短乘客步行距離，則站點必須越密集、離人群越近（目標 B 最小化乘客行走成本）。</li>
                </ul>
                <p>
                    為了在兩個互斥方向中尋找最優解，本模型採用了加權和模型。我們將「步行約束」與「營運成本」整合進同一個目標函數中，透過權重 \( w_1, w_2 \) 來模擬不同的決策偏好。
                </p>
                <div style="background: white; padding: 15px; border-radius: 8px; border: 1px solid #ffeaa7; margin-top: 15px; text-align: center;">
                    <strong>最佳化核心：透過調整權重，在"營運效率"與"行人便利"中間尋找平衡點。</strong>
                </div>
            </div>
        </section>

        <section style="margin-bottom: 40px; background: #fdfdfd; padding: 25px; border-radius: 12px; border: 1px solid #eee;">
            <h2 style="color: #2980b9; border-left: 6px solid #2980b9; padding-left: 15px; margin-bottom: 20px;">(1). 問題建模：圖論與最佳化</h2>
            <p>本系統將問題建模為最小化<b>加權和函數</b> \(L\)，用以平衡營運支出與服務品質：</p>
            
            <div style="background: #fff; padding: 20px; border-radius: 10px; text-align: center; margin: 25px 0; font-size: 1.3em; border: 2px solid #3498db; color: #2c3e50;">
                $$L = w_1 \cdot (n \cdot S_{cost} + Dist_{bus} \cdot C_{bus}) + w_2 \cdot \sum dist(p_i, s_{nearest})$$
            </div>

            <p>公式各項變數與子問題之對應如下：</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 25px; margin-top: 20px;">
                <div style="background: #fff; padding: 15px; border-radius: 8px; border-left: 4px solid #e67e22;">
                    <h4 style="margin-top: 0; color: #d35400;">問題 1：營運成本</h4>
                    <p>對應公式中的前項 \((n \cdot S_{cost} + Dist_{bus} \cdot C_{bus})\)：</p>
                    <ul style="font-size: 0.9em; padding-left: 20px;">
                        <li><b>\(n\)</b>：預計設置的中繼站點總數。</li>
                        <li><b>\(S_{cost}\)</b>：單一站點的固定建設與維護成本。</li>
                        <li><b>\(Dist_{bus}\)</b>：公車從起點 A 經由所有站點至終點 B 的總行駛里程。</li>
                        <li><b>\(C_{bus}\)</b>：公車每單位距離的營運成本。</li>
                    </ul>
                </div>

                <div style="background: #fff; padding: 15px; border-radius: 8px; border-left: 4px solid #e67e22;">
                    <h4 style="margin-top: 0; color: #d35400;">問題 2：行人便捷成本</h4>
                    <p>對應公式中的後項 \(\sum dist(p_i, s_{nearest})\)：</p>
                    <ul style="font-size: 0.9em; padding-left: 20px;">
                        <li><b>\(p_i\)</b>：第 \(i\) 位乘客的座標位置。</li>
                        <li><b>\(s_{nearest}\)</b>：距離該乘客最近的公車站點座標。</li>
                        <li><b>\(dist\)</b>：兩點間的 <b>\(L_2\) 距離</b>。總和代表所有乘客步行負擔。</li>
                        <li><b>\(w_1, w_2\)</b>：代表政府營運與民眾便捷間的權重優先順序。</li>
                    </ul>
                </div>

                <div style="background: #fff; padding: 15px; border-radius: 8px; border-left: 4px solid #27ae60;">
                    <h4 style="margin-top: 0; color: #27ae60;">問題 3：避障最短路徑 (A* Search)</h4>
                    <p>考量系統效能與計算效率，我們將公車移動路徑限制於網格內的 <b>8 個離散方向</b>。此設計的主要目的是為了：</p>
                    <ul style="font-size: 0.9em; padding-left: 20px;">
                        <li><b>限制搜尋空間</b>：將分支因子控制在 \(k=8\)，避免連續空間下的計算爆炸，確保即時反應。</li>
                        <li><b>啟發式函數應用</b>：採用 Octile 距離預估剩餘路程成本。</li>
                    </ul>
                    <div style="background: #f4f4f4; padding: 10px; font-size: 0.85em; margin: 5px 0;">
                        \(H = (dx + dy) + (1.414 - 2) \cdot \min(dx, dy)\)
                    </div>
                    <p style="font-size: 0.85em;"><small><b>註：</b>此函數具備「容許性」，能確保在離散路網限制下，求得營運成本 \(Dist_{bus}\) 的理論最佳解。</small></p>
                </div>

                <div style="background: #fff; padding: 15px; border-radius: 8px; border-left: 4px solid #27ae60;">
                    <h4 style="margin-top: 0; color: #27ae60;">問題 4：最佳站點佈置</h4>
                    <p>這是一個動態決策問題。我們需在禁區限制下，透過演算法找到一組候選座標集合 \(\{s_1, s_2, ..., s_n\}\)，使函數 \(L\) 達到最小值。此過程需同時考慮路徑連通性與乘客覆蓋率。</p>
                </div>
            </div>
        </section>

        <hr style="border: 0; border-top: 1px solid #eee; margin: 40px 0;">

        <section style="margin-top: 40px; background: #fdfdfd; padding: 25px; border-radius: 12px; border: 1px solid #eee;">
            <h2 style="color: #2980b9; border-left: 6px solid #2980b9; padding-left: 15px; margin-bottom: 20px;">(2). 最佳化站點佈置：搜尋空間與策略比較</h2>
            
            <p>在已知<b>禁區限制</b>與<b>行人座標</b>的情況下，搜尋最佳站點佈置與站點順序是一個高度複雜的最佳化問題。我們的目標是在可接受的時間內，找出能使成本函數 \(L\) 達到局部最佳或全域最佳的站點組合。</p>

            <div style="background: #fff; padding: 20px; border-radius: 10px; margin: 20px 0; border: 1px solid #e9ecef;">
                <h4 style="margin-top: 0; color: #34495e;">搜尋空間的轉化</h4>
                <p style="font-size: 0.95em;">
                    雖然我們可以將此問題視為一個全地圖的<b>窮舉問題</b>，但其計算複雜度會隨地圖大小呈幾何倍數增加。
                    為了效能考量，系統將搜尋空間限制在一個具備高潛力的<b>站點候選池</b>內：
                </p>
                <ul style="font-size: 0.9em; line-height: 1.8;">
                    <li><b>K-Means 群聚中心</b>：針對行人進行分群，找到能代表各自人群的平均距離最近的座標。</li>
                    <li><b>行人自身座標</b>：確保"步行距離最小化"的潛在站點位置。</li>
                </ul>
                <p style="font-size: 0.95em;">
                    <b>路徑一致性最佳化：</b> 
                    應注意的是，新插入的公車站點必須符合"從 A 到 B 既有路線中，距離插入點邊際成本最小的兩個節點中間"，
                    才不會導致路徑震盪（例如：在河流兩岸多次往返過河），確保營運里程的最佳化。
                </p>
            </div>

            <table style="width: 100%; border-collapse: collapse; margin-top: 25px; background: white; font-size: 0.95em; box-shadow: 0 4px 6px rgba(0,0,0,0.05);">
                <thead>
                    <tr style="background: #34495e; color: white;">
                        <th style="padding: 12px; border: 1px solid #ddd; width: 25%;">搜尋策略</th>
                        <th style="padding: 12px; border: 1px solid #ddd;">優點</th>
                        <th style="padding: 12px; border: 1px solid #ddd;">缺點</th>
                        <th style="padding: 12px; border: 1px solid #ddd;">適用情境</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 12px; border: 1px solid #ddd; font-weight: bold; color: #c0392b;">全地圖窮舉<br>(Exhaustive Search)</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">能保證找到<b>全域最佳解</b>。</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">搜尋時間極長，無法在即時互動系統中使用。</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">地圖極小或靜態預先規劃。</td>
                    </tr>
                    <tr style="background: #f9f9f9;">
                        <td style="padding: 12px; border: 1px solid #ddd; font-weight: bold; color: #27ae60;">啟發式貪婪法<br>(Heuristic Greedy)</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">針對 [K-Means、行人座標] 進行篩選，運算極快且結果接近最佳解。</td>
                        <td style="padding: 12px; border: 1px solid #ddd;">可能陷入局部最佳解。</td>
                        <td style="padding: 12px; border: 1px solid #ddd;"><b>即時決策支援、動態乘客變更。</b></td>
                    </tr>
                </tbody>
            </table>
            
            <p style="margin-top: 20px; font-size: 0.9em; background: #fff8e1; padding: 10px; border-left: 5px solid #ffc107; border-radius: 4px;">
                <b>系統最終採用：</b> 啟發式貪婪搜尋。透過將搜尋範圍聚焦於關鍵候選座標，我們能在短時間內計算出兼顧建置成本 \(w_1\) 與服務品質 \(w_2\) 的站點佈置。
            </p>
        </section>

        <section style="margin-top: 40px; background: #fff; padding: 25px; border-radius: 12px; border: 1px solid #e1e8ed;">
            <h2 style="color: #2980b9; border-left: 6px solid #2980b9; padding-left: 15px; margin-bottom: 20px;">(3). 路徑生成技術細節：Octile A* 演算法</h2>

            <p>路徑生成模組負責在起點、各站點與終點之間建立合法的物理連線。系統的核心引擎是 A* 演算法，並針對網格地圖進行了最佳化。</p>

            <div style="margin-bottom: 25px;">
                <h4 style="color: #34495e; margin-bottom: 10px;">1. 核心演算法：A-Star</h4>
                <p style="font-size: 0.92em; line-height: 1.6;">
                    系統採用 A* 演算法作為路徑規劃引擎。透過啟發式估計函數（Heuristic）引導搜尋，確保公車能從起點 A 經由各個優化站點到達終點 B。該演算法透過維護一個優先隊列，優先探索總預估成本 \( f(n) = g(n) + h(n) \) 最小的節點。
                </p>
            </div>

            <div style="margin-bottom: 25px;">
                <h4 style="color: #34495e; margin-bottom: 10px;">2. 移動規則：Octile Distance (八向移動限制)</h4>
                <p style="font-size: 0.92em; line-height: 1.6; margin-left: 5px;">
                    為了模擬真實的道路轉向，我們不使用四方向移動（曼哈頓距離），採用 <b>Octile 距離</b> 規範：
                </p>
                <ul style="font-size: 0.9em; line-height: 1.8; margin-left: 5px;">
                    <li><b>移動權重</b>：水平與垂直移動成本為 \( 1.0 \)，對角線（45度角）移動成本為 \( \sqrt{2} \approx 1.414 \)。</li>
                    <li><b>效果</b>：這使得路徑視覺上不再是僵硬的 90 度轉彎，而是能以斜向穿梭於建築物間，更貼近現實道路樣態。</li>
                </ul>
            </div>

            <div style="margin-bottom: 10px;">
                <h4 style="color: #34495e; margin-bottom: 10px;">3. 障礙物避讓與連通性</h4>
                <p style="font-size: 0.92em; line-height: 1.6;">
                    演算法在搜尋過程中會即時比對 <b>wallsSet</b> 數據。每當搜尋到新節點時，系統會立即檢查該座標是否屬於禁區：
                </p>
                <div style="background: #2d3436; color: #fab1a0; padding: 12px; font-family: 'Courier New', monospace; font-size: 0.85em; border-radius: 5px; margin: 10px 0;">
                    if (wallsSet.has(`${nextX},${nextY}`)) continue; // 立即捨棄牆內路徑
                </div>
                <p style="font-size: 0.92em;">
                    這確保了生成的路徑絕對不會重疊於任何禁區座標。在 <b>Toy Demo</b> 的河流場景中，演算法會自動鎖定唯一合法的橋樑節點 <b>(10, 10)</b> 作為跨區路徑的必經之處，展現了演算法的環境感知與規劃能力。
                </p>
                
            </div>
            <div style="margin-bottom: 10px;">
                <h4 style="color: #34495e; margin-bottom: 10px;">4. 多站點序列生成：從空路徑到動態插入</h4>
                <p style="font-size: 0.92em; line-height: 1.6; margin-left: 5px;">
                    路徑生成並非一次性完成，而是隨優化過程從"空白路徑 == [A,B]"逐步演進：
                </p>
                <div style="background: #f0f4f8; padding: 20px; border-radius: 8px; border-left: 5px solid #27ae60; margin-left: 5px; margin-top: 10px;">
                    <ul style="font-size: 0.9em; line-height: 1.8; margin: 0; padding-left: 20px;">
                        <li><b>初始化階段：</b> 此時站點清單為空，系統先建立基礎 <b>[A] → [B]</b> 軌跡作為基準成本。</li>
                        <li><b>逐一候選評估：</b> 選定一個具備潛力的候選點 \( S \) 時，系統會掃描當前序列中所有的「路段間隙」。</li>
                        <li><b>執行最省成本插入：</b> 
                            透過公式 \( \Delta Dist = Dist(N_i, S) + Dist(S, N_{i+1}) - Dist(N_i, N_{i+1}) \)，
                            將該候選點置於 <b>增加成本最小</b> 的位置，確保地理連續性。
                        </li>
                        <li><b>遞迴增長：</b> 每成功插入一個點，便形成新的路徑基準。此過程不斷重複，直到新增任何候選點都無法再降低總成本函數 \( L \) 為止。</li>
                    </ul>
                </div>
                
                <p style="font-size: 0.85em; color: #c0392b; margin-top: 10px; margin-left: 5px;">
                    <i>※ 註：此動態插入機制有效解決了多站點環境下，因排序不當導致的「反覆過河」或「大幅繞路」等非最優解問題。</i>
                </p>
            </div>


        </section>

        <section style="margin-top: 40px; background: #fff; padding: 25px; border-radius: 12px; border: 1px solid #e1e8ed;">
            <h2 style="color: #2c3e50; border-left: 6px solid #f39c12; padding-left: 15px; margin-bottom: 20px;">(4). 系統操作指南 (System Manual)</h2>

            <p style="font-size: 0.95em; color: #666;">本模擬系統提供手動配置與 AI 自動化優化兩大模式，使用者可透過控制面板即時調整城市運輸參數。</p>

            <table style="width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 0.9em;">
                <thead>
                    <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                        <th style="padding: 12px; text-align: left; width: 30%;">功能按鈕</th>
                        <th style="padding: 12px; text-align: left;">操作說明</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;"><b>🚫 禁區 (Walls)</b></td>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;">點擊後可在地圖上繪製無法通行的建築物或河流。</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;"><b>👥 乘客 (Passengers)</b></td>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;">點擊後在地圖上標記需求點，作為 AI 選址的參考數據。</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;"><b>🚏 站牌 (Stations)</b></td>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;">手動放置預定站點，系統將自動計算其與起終點的連通路徑。</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;"><b>🗑️ 清空 (Clear)</b></td>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;">重置地圖，清除所有自定義的站點、乘客與路徑資料。</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;"><b>⚙️ 執行運算 (Run)</b></td>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;">觸發 A* 演算法，根據當前站點序列計算最優導航路徑。</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;"><b>🤖 AI 自動選址 (Optimize)</b></td>
                        <td style="padding: 10px; border-bottom: 1px solid #eee;">啟用智慧優化邏輯，自動根據權重與候選池產出最優站點配置。</td>
                    </tr>
                </tbody>
            </table>

            <div style="margin-top: 25px; padding: 20px; background: #fff9f0; border-radius: 10px; border: 1px solid #ffeaa7;">
                <h4 style="margin: 0 0 15px 0; color: #e67e22;">⚖️ 權重動態調整 (Weight Tuning)</h4>
                <p style="font-size: 0.9em; line-height: 1.6;">
                    系統提供<b>滑桿 (Bar)</b> 與<b>數值輸入框</b>雙向連動，用於定義「理想運輸模型」的偏好：
                </p>
                <div style="display: flex; gap: 20px; margin-top: 10px;">
                    <div style="flex: 1; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);">
                        <span style="font-weight: bold; color: #2980b9;">Bus Distance (w1)</span>
                        <p style="font-size: 0.85em; margin: 5px 0;">調高時，系統會優先縮短公車總里程（省油、節省營運時間）。</p>
                    </div>
                    <div style="flex: 1; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);">
                        <span style="font-weight: bold; color: #27ae60;">Pedestrian Distance (w2)</span>
                        <p style="font-size: 0.85em; margin: 5px 0;">調高時，系統會讓站點更靠近乘客（提升便利性、減少步行負擔）。</p>
                    </div>
                </div>
                <p style="font-size: 0.85em; color: #7f8c8d; margin-top: 15px;">
                    <i>* 註：如需載入預設場景（如 Toy Demo 河流圖），請直接「重新整理」頁面。</i>
                </p>
            </div>
        </section>
            
        </div>
    </div>



    <h2 style="margin-bottom:10px;">🚌 公車 LRP 規劃工具</h2>
        <div style="margin-bottom: 20px;">
            <a href="https://github.com/franktpmvu/bus-stop-optimization" target="_blank" style="
                display: inline-flex;
                align-items: center;
                padding: 5px 12px;
                background-color: #24292e;
                color: white;
                text-decoration: none;
                border-radius: 6px;
                font-size: 0.85em;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
                transition: background-color 0.2s;
            ">
                <svg height="16" viewBox="0 0 16 16" version="1.1" width="16" aria-hidden="true" style="fill: white; margin-right: 8px;">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
                View Source Code (HTML Hybrid Python)
            </a>
        </div>

    <div id="pyscript-loading" style="color:orange; font-weight:bold;">系統核心載入中...</div>

    <div class="main-container">
        <canvas id="mapCanvas" width="600" height="600"></canvas>

    <div class="panel">
        <div class="btn-group">
            <button onclick="setMode('wall')" id="btn-wall" class="active">🚫 禁區</button>
            <button onclick="setMode('passenger')" id="btn-passenger">👤 乘客</button>
            <button onclick="setMode('station')" id="btn-station">🚏 站牌</button>
            <button onclick="resetMap()" style="background:#e74c3c; color:white;">🗑️ 清空</button>
            <button id="btn-run" onclick="triggerOptimization()">⚙️ 執行運算</button>
            <button id="btn-auto" onclick="triggerAutoOptimize()" style="background:#9b59b6; color:white; grid-column: span 2; margin-top: 5px; border: none;">🤖 AI 自動選址 (weighted sum)</button>
        </div>

        <hr style="margin: 20px 0; border: 0; border-top: 1px solid #eee;">

        <div style="margin-bottom: 15px;">
            <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                營運權重 w1: <span id="w1-v" style="color: #27ae60; float: right;">1.0</span>
            </label>
            <input type="range" id="w1" min="0" max="10" step="0.5" value="1.0" oninput="updateWeights()" style="width: 100%; cursor: pointer;">
        </div>

        <div style="margin-bottom: 20px;">
            <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                步行權重 w2: <span id="w2-v" style="color: #3498db; float: right;">1.0</span>
            </label>
            <input type="range" id="w2" min="0" max="10" step="0.5" value="1.0" oninput="updateWeights()" style="width: 100%; cursor: pointer;">
        </div>

        <div style="margin-bottom: 15px;">
            <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                站牌設置成本 (S): <span id="s-cost-v" style="color: #e67e22; float: right;">10</span>
            </label>
            <input type="number" id="s-cost" value="10" min="0" step="1" oninput="updateWeights()" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">
        </div>

        <div style="margin-bottom: 20px;">
            <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                公車行走成本 (C): <span id="c-bus-v" style="color: #7f8c8d; float: right;">1.0</span>
            </label>
            <input type="number" id="c-bus" value="1.0" min="0.1" step="0.1" oninput="updateWeights()" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;">
        </div>

        <div class="result-box" id="py-output">等待指令...</div>
    </div>

    </div>

<script>
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const gridSize = 30;
    
    window.wallsArray = [];
    window.passengers = [];
    window.stations = [];
    let mode = 'wall';
    let wallsSet = new Set();


    function setMode(m) {
        mode = m;
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-' + m).classList.add('active');
    }

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / (rect.width / 20));
        const y = Math.floor((e.clientY - rect.top) / (rect.height / 20));
        
        if (mode === 'wall') {
            const key = `${x},${y}`;
            if (wallsSet.has(key)) wallsSet.delete(key); else wallsSet.add(key);
            window.wallsArray = Array.from(wallsSet);
        } else if (mode === 'passenger') window.passengers.push({x, y});
        else if (mode === 'station') window.stations.push({x, y});
        drawBase();
    });

    function resetMap() {
        wallsSet.clear(); window.wallsArray=[]; window.passengers=[]; window.stations=[];
        drawBase();
    }

    function updateWeights() {
        document.getElementById('w1-v').innerText = document.getElementById('w1').value;
        document.getElementById('w2-v').innerText = document.getElementById('w2').value;
        document.getElementById('s-cost-v').innerText = document.getElementById('s-cost').value;
        document.getElementById('c-bus-v').innerText = document.getElementById('c-bus').value;
    }
    
    function triggerOptimization() {
        if (window.runOptimization) window.runOptimization();
    }
    function triggerAutoOptimize() {
        if (window.autoOptimize) {
            document.getElementById('py-output').innerText = "AI 正在計算最佳站點配置...";
            window.autoOptimize(); // 呼叫 Python 的優化函式
        }
    }

    // 這個函式讓 Python 算完後，把站點位置更新到地圖上
    window.updateStationsFromPy = function(newStationsProxy) {
        // 將 Python 資料轉回 JS 格式
        window.stations = Array.from(newStationsProxy).map(p => ({
            x: (typeof p.x !== 'undefined') ? p.x : p.get('x'),
            y: (typeof p.y !== 'undefined') ? p.y : p.get('y')
        }));
        drawBase(); // 重新畫圖，讓站點出現在畫面上
    };
    

    function drawBase() {
        ctx.clearRect(0, 0, 600, 600);
        ctx.strokeStyle = '#eee';
        for(let i=0; i<20; i++) {
            for(let j=0; j<20; j++) {
                ctx.strokeRect(i*30, j*30, 30, 30);
                if(wallsSet.has(`${i},${j}`)) {
                    ctx.fillStyle = '#ff7675';
                    ctx.fillRect(i*30, j*30, 30, 30);
                }
            }
        }
        window.passengers.forEach(p => drawPoint(p.x, p.y, '#3498db', 'P'));
        window.stations.forEach((s,i) => drawPoint(s.x, s.y, '#2ecc71', 'S'+(i+1)));
        drawPoint(1, 1, 'gold', 'A'); drawPoint(18, 18, 'orange', 'B');
    }

    function drawPoint(x, y, color, label) {
        const cx = x * 30 + 15;
        const cy = y * 30 + 15;
        
        // 檢查是否有重疊 (透過標籤開頭判斷)
        const isStation = label.startsWith('S');
        const isPassenger = label.startsWith('P');

        ctx.save();
        
        if (isStation) {
            // 站點畫大一點，當作底座
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 標籤寫在上方
            ctx.fillStyle = "black";
            ctx.font = "bold 10px Arial";
            ctx.textAlign = "center";
            ctx.fillText(label, cx, cy - 14);
        } 
        else if (isPassenger) {
            // 乘客畫小一點，並加上陰影/邊框
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // 標籤寫在下方
            ctx.fillStyle = "#2980b9";
            ctx.font = "9px Arial";
            ctx.textAlign = "center";
            ctx.fillText(label, cx, cy + 18);
        } 
        else {
            // 起點(A)與終點(B)維持原樣
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "black";
            ctx.fillText(label, cx - 5, cy + 4);
        }
        
        ctx.restore();
    }
    
    // 關鍵修正：確保 path 是純 JS 陣列
    window.renderPath = function(pathProxy, color, isDashed) {
        // 強制轉換：處理 Python Proxy 物件，確保轉成純 JS Array
        let rawPath = Array.from(pathProxy);
        let path = rawPath.map(p => {
            // 兼容處理：同時嘗試讀取屬性與字典 key
            let x = (typeof p.x !== 'undefined') ? p.x : p.get('x');
            let y = (typeof p.y !== 'undefined') ? p.y : p.get('y');
            return { x: Number(x), y: Number(y) };
        });

        if (path.length < 2) return;

        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = isDashed ? 2 : 4;
        if (isDashed) ctx.setLineDash([5, 5]);
        
        // 繪製路徑主體
        ctx.moveTo(path[0].x * 30 + 15, path[0].y * 30 + 15);
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo(path[i].x * 30 + 15, path[i].y * 30 + 15);
        }
        ctx.stroke();

        // 繪製箭頭
        ctx.setLineDash([]);
        ctx.fillStyle = color;
        
        // 遍歷路徑畫箭頭
        for (let i = 1; i < path.length; i++) {
            // 公車實線(橘)：每一格中間都畫；行人虛線(藍)：只在最後一格(站點處)畫
            if (!isDashed || i === path.length - 1) {
                drawArrowhead(path[i-1], path[i], color, isDashed ? 8 : 12);
            }
        }
        ctx.restore();
    };
    function drawArrowhead(from, to, color, size) {
        const tx = to.x * 30 + 15;
        const ty = to.y * 30 + 15;
        const fx = from.x * 30 + 15;
        const fy = from.y * 30 + 15;
        
        // 計算角度
        const angle = Math.atan2(ty - fy, tx - fx);
        
        ctx.beginPath();
        ctx.moveTo(tx, ty); // 箭頭尖端在目標點中心
        // 繪製兩翼
        ctx.lineTo(tx - size * Math.cos(angle - Math.PI/6), ty - size * Math.sin(angle - Math.PI/6));
        ctx.lineTo(tx - size * Math.cos(angle + Math.PI/6), ty - size * Math.sin(angle + Math.PI/6));
        ctx.closePath();
        ctx.fill();
    }
    window.onload = () => drawBase();

    function loadToyDemo() {
        console.log("正在重置 Toy Demo...");
        
        // 1. 完全清空現有數據
        wallsSet.clear(); // 務必清空 Set，否則舊牆會留著
        window.wallsArray = [];
        window.passengers = [];
        window.stations = []; 

        // 2. 地形建設：中央河流
        for (let x = 0; x < 20; x++) {
            if (x !== 10) {
                wallsSet.add(`${x},10`); // 同步更新到 Set 供 drawBase 使用
            }
        }

        // 3. 地形建設：右下角「封閉式社區」
        for (let x = 12; x <= 16; x++) {
                for (let y = 12; y <= 16; y++) {
                    // 如果是外框且不是門口 (14,16)
                    if ((x === 12 || x === 16 || y === 12 || y === 16) && !(x === 14 && y === 16)) {
                        wallsSet.add(`${x},${y}`);
                    }
                }
            }
        // 4. 地形建設：左上角「半開放式社區」
        const openWalls = [
            [3, 3], [4, 3], [6, 3], [7, 3], // Y=3 橫向有缺口
            [3, 5], [5, 5], [7, 5],         // Y=5 錯落分佈
            [4, 7], [6, 7]                  // Y=7 寬鬆分佈
        ];
        openWalls.forEach(w => wallsSet.add(`${w[0]},${w[1]}`));

        // 5. 同步 wallsArray (轉成 Python 認識的格式)
        window.wallsArray = Array.from(wallsSet);

        // 6. 放置 20 位行人
        const p = [];
        p.push({x: 2, y: 2}, {x: 5, y: 2}, {x: 8, y: 3}, {x: 15, y: 2}, {x: 18, y: 3});
        for(let i=0; i<8; i++) {
            p.push({x: 13 + (i%3), y: 13 + Math.floor(i/3)});
        }
        p.push({x: 4, y: 14}, {x: 5, y: 15}, {x: 2, y: 18}, {x: 8, y: 12}, {x: 12, y: 18}, {x: 8, y: 17}, {x: 15, y: 18});        window.passengers = p;

        // 7. 更新畫面：你的繪圖函數名稱是 drawBase
        if(document.querySelector("#w1")) document.querySelector("#w1").value = 1.0;
        if(document.querySelector("#w2")) document.querySelector("#w2").value = 1.0;
        drawBase();
    }

    window.addEventListener('DOMContentLoaded', () => {
        // 稍微延遲確保 Pyodide 準備就緒
        setTimeout(() => {
            loadToyDemo();
            // 確保執行 drawBase
            if (typeof drawBase === 'function') {
                drawBase();
            }
        }, 500); 
    });

</script>

<script type="py">
from pyscript import window, document
import math

class AStar:
    def solve(self, start, end, walls):
        # 確保 start/end 是整數
        sx, sy = int(round(start['x'])), int(round(start['y']))
        ex, ey = int(round(end['x'])), int(round(end['y']))
        
        open_set = [{'x': sx, 'y': sy}]
        came_from = {}
        g = {(sx, sy): 0}
        
        while open_set:
            curr = min(open_set, key=lambda n: g[(n['x'], n['y'])] + self.heuristic(n, {'x': ex, 'y': ey}))
            
            if curr['x'] == ex and curr['y'] == ey:
                res = []
                while (curr['x'], curr['y']) in came_from:
                    res.append(curr)
                    curr = came_from[(curr['x'], curr['y'])]
                res.append({'x': sx, 'y': sy})
                return res[::-1]
            
            open_set.remove(curr)
            
            # 8 方向
            directions = [
                (0, 1, 1), (0, -1, 1), (1, 0, 1), (-1, 0, 1),
                (1, 1, 1.414), (1, -1, 1.414), (-1, 1, 1.414), (-1, -1, 1.414)
            ]
            
            for dx, dy, cost in directions:
                nx, ny = int(curr['x'] + dx), int(curr['y'] + dy)
                
                # --- [關鍵修正：統一使用 Tuple 比對] ---
                if 0 <= nx < 20 and 0 <= ny < 20 and (nx, ny) not in walls:
                    # 選配：防止斜向穿過牆角縫隙 (建議開啟)
                    if dx != 0 and dy != 0:
                        if (curr['x'] + dx, curr['y']) in walls and (curr['x'], curr['y'] + dy) in walls:
                            continue

                    new_g = g[(curr['x'], curr['y'])] + cost
                    if new_g < g.get((nx, ny), 9999):
                        came_from[(nx, ny)] = curr
                        g[(nx, ny)] = new_g
                        # 檢查是否已在 open_set 中 (比較座標而非物件)
                        if not any(n['x'] == nx and n['y'] == ny for n in open_set):
                            open_set.append({'x': nx, 'y': ny})
                            
        return [{'x': sx, 'y': sy}, {'x': ex, 'y': ey}] # 找不到路徑時回傳直線

    def heuristic(self, a, b):
        dx = abs(a['x'] - b['x'])
        dy = abs(a['y'] - b['y'])
        return (dx + dy) + (1.414 - 2) * min(dx, dy)


def simple_kmeans(points, k, iterations=10):
    if not points or k <= 0: return []
    
    # 1. 初始中心點
    centers = [{'x': float(p['x']), 'y': float(p['y'])} for p in points[:k]]
    
    for _ in range(iterations):
        clusters = [[] for _ in range(k)]
        for p in points:
            px, py = float(p['x']), float(p['y'])
            dists = [math.sqrt((px - c['x'])**2 + (py - c['y'])**2) for c in centers]
            idx = dists.index(min(dists))
            clusters[idx].append(p)
        
        new_centers = []
        for i in range(k):
            if not clusters[i]: 
                new_centers.append(centers[i])
                continue
            avg_x = sum(float(p['x']) for p in clusters[i]) / len(clusters[i])
            avg_y = sum(float(p['y']) for p in clusters[i]) / len(clusters[i])
            
            # --- [關鍵修正：末尾對齊] ---
            # 四捨五入後轉為 int，並確保型別是與乘客點一致的 dictionary
            new_centers.append({
                'x': int(round(avg_x)), 
                'y': int(round(avg_y))
            })
        centers = new_centers
        
    return centers

def get_optimal_sequence(start_node, end_node, station_list):
    """
    使用簡單的插入啟發式 (Insertion Heuristic) 確保站點順序合理
    """
    optimized_route = [start_node, end_node]
    
    # 將站點一個一個插入到最適合的位置
    for s in station_list:
        best_increase = float('inf')
        best_index = 1
        
        for i in range(len(optimized_route) - 1):
            n1 = optimized_route[i]
            n2 = optimized_route[i+1]
            
            # 計算插入該站點後增加的里程
            # 這裡可以直接用 Octile 距離快速預估，不需要每次都跑 A*
            d1 = octile_distance(n1, s)
            d2 = octile_distance(s, n2)
            d_orig = octile_distance(n1, n2)
            
            increase = d1 + d2 - d_orig
            if increase < best_increase:
                best_increase = increase
                best_index = i + 1
        
        optimized_route.insert(best_index, s)
    
    return optimized_route # 回傳 [A, S_best1, S_best2, ..., B]

def run_optimization(event=None):
    try:
        raw_walls = window.wallsArray.to_py()
        walls = set()
        for w in raw_walls:
            try:
                if isinstance(w, str) and ',' in w:
                    # 處理字串格式 '9,2' -> 轉為整數 (9, 2)
                    parts = w.split(',')
                    walls.add((int(parts[0].strip()), int(parts[1].strip())))
                elif hasattr(w, '__getitem__') and len(w) >= 2:
                    # 處理列表格式 [9, 2] -> 轉為整數 (9, 2)
                    walls.add((int(w[0]), int(w[1])))
            except (ValueError, TypeError):
                continue
        print(f"DEBUG - 牆壁座標範例: {list(walls)[:5]}")
        ps = window.passengers.to_py()
        ss = window.stations.to_py()
        
        w1 = float(document.querySelector("#w1").value)
        w2 = float(document.querySelector("#w2").value)
        s_cost_unit = float(document.querySelector("#s-cost").value)
        c_bus_unit = float(document.querySelector("#c-bus").value)
        
        window.drawBase()
        solver = AStar()
        
        # 1. 行人成本與渲染 (L2 距離)
        ped_total_d = 0
        all_nodes = ss + [{'x': 1, 'y': 1}, {'x': 18, 'y': 18}]
        for p in ps:
            closest_node = min(all_nodes, key=lambda n: math.sqrt((p['x']-n['x'])**2 + (p['y']-n['y'])**2))
            dist = math.sqrt((p['x']-closest_node['x'])**2 + (p['y']-closest_node['y'])**2)
            ped_total_d += dist
            window.renderPath([p, closest_node], "rgba(52, 152, 219, 0.6)", True)

        # 2. 公車成本與渲染 (8方向路徑)
        route = [{'x': 1, 'y': 1}] + ss + [{'x': 18, 'y': 18}]
        bus_total_d = 0
        for i in range(len(route)-1):
            seg = solver.solve(route[i], route[i+1], walls)
            for j in range(len(seg)-1):
                dx, dy = abs(seg[j]['x']-seg[j+1]['x']), abs(seg[j]['y']-seg[j+1]['y'])
                bus_total_d += 1.4142 if (dx > 0 and dy > 0) else 1
            window.renderPath(seg, "#f39c12", False)

        # 3. 各項分項成本計算
        station_total_cost = len(ss) * s_cost_unit  # 站牌成本
        bus_op_cost = w1 * bus_total_d * c_bus_unit # 營運成本
        ped_walk_cost = w2 * ped_total_d            # 步行成本
        
        total_lagrangian = bus_op_cost + ped_walk_cost + station_total_cost
        
        # 4. 格式化輸出報告
        output =  "【 成本統計報告 】\n"
        output += f"----------------------------\n"
        output += f"🚌 公車總距離: {bus_total_d:.2f}\n"
        output += f"💰 營運總成本: {bus_op_cost:.2f} (w1*dist*C)\n"
        output += f"----------------------------\n"
        output += f"🚏 站牌總數量: {len(ss)} 站\n"
        output += f"🏗️ 站牌總成本: {station_total_cost:.2f} (N*S)\n"
        output += f"----------------------------\n"
        output += f"🚶 行人總步行: {ped_total_d:.2f}\n"
        output += f"👟 步行總成本: {ped_walk_cost:.2f} (w2*dist)\n"
        output += f"============================\n"
        output += f"🚀 總加權和成本: {total_lagrangian:.2f}"
        
        document.querySelector("#py-output").innerText = output
        
    except Exception as e:
        document.querySelector("#py-output").innerText = f"運算錯誤: {e}"


def get_total_cost(stations, passengers, walls, w1, w2, s_cost, c_bus):
    solver = AStar()
    # 1. 公車路徑 (起點 -> 所有中繼站 -> 終點)
    route = [{'x': 1, 'y': 1}] + stations + [{'x': 18, 'y': 18}]
    bus_d = 0
    for i in range(len(route)-1):
        seg = solver.solve(route[i], route[i+1], walls)
        for j in range(len(seg)-1):
            dx = abs(seg[j]['x'] - seg[j+1]['x'])
            dy = abs(seg[j]['y'] - seg[j+1]['y'])
            # 8方向距離累加
            bus_d += 1.414 if (dx > 0 and dy > 0) else 1
            
    # 2. 行人成本：將 [起點, 終點] 與 [站點] 合併考慮
    ped_d = 0
    # 關鍵：這裡確保了即使 stations 是空的，也有節點可以計算距離
    all_available_nodes = stations + [{'x': 1, 'y': 1}, {'x': 18, 'y': 18}]
    
    for p in passengers:
        # 計算乘客到最近節點的 L2 距離
        dists = [math.sqrt((p['x']-n['x'])**2 + (p['y']-n['y'])**2) for n in all_available_nodes]
        ped_d += min(dists)
        
    return (w1 * bus_d * c_bus) + (w2 * ped_d) + (len(stations) * s_cost)


def is_reachable(p, walls):
    """
    精確檢查：1. 是否在牆內 2. 是否能連通
    """
    # 確保座標是整數
    tx, ty = int(p['x']), int(p['y'])
    
    # 調查：在 Python 端印出座標，讓你檢查 X Y 是否反了
    print(f"檢查乘客位置: x={tx}, y={ty}")
    
    # 1. 物理檢查：如果是牆，直接剔除
    # 注意：這裡的 (tx, ty) 必須與你當初存入 walls 的順序完全一致
    if (tx, ty) in walls:
        print(f"判定結果: 點 ({tx}, {ty}) 在牆內，剔除。")
        return False
        
    # 2. 連通檢查
    solver = AStar()
    # 起點固定為 (1, 1)
    path = solver.solve({'x': 1, 'y': 1}, {'x': tx, 'y': ty}, walls)
    
    reachable = len(path) > 0 or (tx == 1 and ty == 1)
    if not reachable:
        print(f"判定結果: 點 ({tx}, {ty}) 是孤島，剔除。")
        
    return reachable    

def fast_dist(p1, p2):
    # 支援字典格式或元組格式
    x1, y1 = (p1['x'], p1['y']) if isinstance(p1, dict) else (p1[0], p1[1])
    x2, y2 = (p2['x'], p2['y']) if isinstance(p2, dict) else (p2[0], p2[1])
    dx, dy = abs(x1 - x2), abs(y1 - y2)
    return (dx + dy) + (1.414 - 2) * min(dx, dy)

def sort_stations_insertion(start_node, end_node, stations):
    """最省成本插入法：確保站點順序在地理上是連貫的"""
    if not stations: return []
    route = [start_node, end_node]
    
    # 建立副本以免更動原始資料
    remaining = list(stations)
    
    # 每次挑選一個站點，插入到增加里程最小的位置
    # 注意：這裡為了簡化，直接按順序插入，若要更準確可先算所有站點
    for s in remaining:
        best_inc = float('inf')
        insert_idx = 1
        for i in range(len(route) - 1):
            d1 = fast_dist(route[i], s)
            d2 = fast_dist(s, route[i+1])
            d_orig = fast_dist(route[i], route[i+1])
            inc = d1 + d2 - d_orig
            if inc < best_inc:
                best_inc = inc
                insert_idx = i + 1
        route.insert(insert_idx, s)
    
    # 回傳排除掉 A, B 的站點序列
    return route[1:-1]


def auto_optimize(event=None):
    try:
        # 1. 讀取 UI 參數
        w1 = float(document.querySelector("#w1").value)
        w2 = float(document.querySelector("#w2").value)
        s_cost = float(document.querySelector("#s-cost").value)
        c_bus = float(document.querySelector("#c-bus").value)
        
        # 2. 強健的牆壁解析 (解決 ',' 報錯問題)
        raw_walls = window.wallsArray.to_py()
        walls = set()
        for w in raw_walls:
            try:
                # 判斷 w 是否為可迭代對象且長度至少為 2
                if hasattr(w, '__getitem__') and len(w) >= 2:
                    walls.add((int(w[0]), int(w[1])))
                # 如果 w 本身是個逗號字串或髒資料，這裡會被 skip
            except (ValueError, TypeError):
                continue

        ps = window.passengers.to_py()
        if not ps:
            document.querySelector("#py-output").innerText = "提醒：地圖上沒有乘客。"
            return

        # --- [1. 建立初始候選點清單] ---
        candidates_raw = []

        # A. 乘客點 (需連通)
        for p in ps:
            if is_reachable(p, walls):
                candidates_raw.append({'x': int(p['x']), 'y': int(p['y'])})

        # B. K-Means 聚類中心
        # 嘗試不同的群組數量，這可以找到「多個乘客的中間點」
        max_k = min(len(ps), 5)
        for k in range(2, max_k + 1):
            centers = simple_kmeans(ps, k)
            for c in centers:
                cx, cy = int(c['x']), int(c['y'])
                
                # 這是關鍵修正：如果中心點不合法，進行「螺旋搜尋」找到最近的合法空地
                if not is_reachable({'x': cx, 'y': cy}, walls):
                    found_valid = False
                    # 擴大搜尋範圍到半徑 2 (5x5 區域)
                    for r in range(1, 3): 
                        for dx in range(-r, r + 1):
                            for dy in range(-r, r + 1):
                                test_c = {'x': cx + dx, 'y': cy + dy}
                                if is_reachable(test_c, walls):
                                    candidates_raw.append(test_c)
                                    found_valid = True
                                    break
                            if found_valid: break
                        if found_valid: break
                    # 如果 5x5 都找不到合法點，代表這區全是牆，直接放棄這個中心點
                else:
                    candidates_raw.append({'x': cx, 'y': cy})

        # --- [2. 移除重複的候選點] ---
        unique_candidates = []
        seen = set()
        for c in candidates_raw:
            pos = (int(c['x']), int(c['y']))
            if pos not in seen:
                unique_candidates.append(c)
                seen.add(pos)

        # --- [3. 執行貪婪選址] ---
        current_ss = [] 
        best_cost = get_total_cost(current_ss, ps, walls, w1, w2, s_cost, c_bus)
        
        print(f"候選點總數: {len(unique_candidates)}")
        START_A = {'x': 1, 'y': 1}
        END_B = {'x': 18, 'y': 18}

        while True:
            best_candidate = None
            for cand in unique_candidates:
                if any(s['x'] == cand['x'] and s['y'] == cand['y'] for s in current_ss):
                    continue
                
                # --- 關鍵修正點 ---
                # 不要直接加在最後，而是先找出「如果加入這個點，最順路的順序是什麼」
                temp_list = current_ss + [cand]
                sorted_test_ss = sort_stations_insertion(START_A, END_B, temp_list)
                
                # 用排序後的順序計算成本
                test_cost = get_total_cost(sorted_test_ss, ps, walls, w1, w2, s_cost, c_bus)
                
                if test_cost < best_cost:
                    best_cost = test_cost
                    best_candidate = cand
            
            if best_candidate:
                current_ss.append(best_candidate)
                # 為了下一次循環，這裡也可以保持 current_ss 是排序過的，或者不排也可以，
                # 因為循環開頭會重新跑 sort_stations_insertion
                current_ss = sort_stations_insertion(START_A, END_B, current_ss)
                print(f"新增優化站點: ({best_candidate['x']}, {best_candidate['y']})")
            else:
                break 

        # 最終輸出前再確保一次順序
        final_ss = sort_stations_insertion(START_A, END_B, current_ss)
        window.updateStationsFromPy(final_ss)
        run_optimization()

    except Exception as e:
        import traceback
        document.querySelector("#py-output").innerText = f"優化失敗: {e}\n{traceback.format_exc()}"


window.autoOptimize = auto_optimize
window.runOptimization = run_optimization
document.querySelector("#pyscript-loading").style.display = "none"
</script>

</body>
</html>